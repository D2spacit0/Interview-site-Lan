> 之前有小伙伴问银行的金融科技岗的面试，给大家分享下比较有代表性的招银的面试情况。从整个体验来看，前面两面技术面和大部分互联网公司面试差不多，技术面中项目问的比较多，但是问题基本上都是常规题目，如果前期有所准备应该问题是不大的。HR面问的很尬。

<!-- TOC -->

- [1 、一面](#1-一面)
- [2 二面(50分钟)](#2-二面50分钟)
- [3 三面hr面](#3-三面hr面)
- [4 知识复盘](#4-知识复盘)

<!-- /TOC -->


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [1 、一面](#1-一面)
* [2 二面(50分钟)](#2-二面50分钟)
* [3 三面hr面](#3-三面hr面)
* [4 知识复盘](#4-知识复盘)

<!-- /code_chunk_output -->



## 1 、一面

> 一面使用牛客远程面试。

1 自我介绍

> 常规，个人基本兴趣，做了什么事情，遇到哪些问题，怎么解决等，尽量的往工作岗位上面靠拢

2 项目介绍

> 项目简介，担任的角色，根据你的项目提出几个问题，如果面试官在行，会衍生项目进行提问

3 sql语句

4 单线程与多线程


<div align="center"> <img src="https://github.com/MikeCreken/Interview-site-Lan/blob/master/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AF%A6%E8%A7%A3/%E6%8B%9B%E9%93%B6/img/test1.png?raw=true" width="650px" /> </div><br>


- 进程中的任意一个线程出错，将导致整个进程崩溃

  假设将之前的伪代码修改为

  X=5+2

  Y=8/0

  Z=5*2

此时Y很明显就是错的，当线程执行到Y的时候就会报错，进程崩溃大致其他两个线程也没有结果

- 当一个进程关闭后，操作系统会回收进程占用的资源

> 比如我们会使用很多不错的Chrome插件，当启动浏览器并打开这些插件的时候，都会占用内存，当关闭进程Chrome浏览器，这些内存就会被收回

- 进程之间内容相互隔离

> 这个机制是防止多个进程读写混乱，所以进程之间通信需要IPC(消息队列，共享内存等)。

- 线程之间共享进程数据



<div align="center"> <img src="https://github.com/MikeCreken/Interview-site-Lan/blob/master/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AF%A6%E8%A7%A3/%E6%8B%9B%E9%93%B6/img/test2.png?raw=true" width="650px" /> </div><br>

从上图我们可以知道线程1，2和线程3分别将数据写入ABC，线程2在负责处理ABC三种读取数据并显示

现在我们基本上了解了线程和进程。我们详细想象，某宝级别的系统架构一开始就能抵抗这么大的流量吗，当然不是，最开始小黄页的单体架构，随着需求的复杂和多样化主键演变而来。

5 死锁 如何避免

- 先介绍下什么是死锁

> 当两个线程相互等待对方释放资源就容易繁盛死锁

- 死锁的必要条件

互斥：资源不能被共享只能由一个进程使用

请求与等待：进程已经获得了一些资源，但是请求其他资源的时候被阻塞，对当前获得资源不释放

不可抢占：有些进程已获得资源后，系统并不能强行的手绘，而是需要进程使用完后自行释放

循环等待：若干个进程形成了环形链，每一个都占用了对方申请的资源。

敲黑板：请自行写一个死锁的程序

- 死锁的避免

方法1：避免多次锁定。即避免同一个线程对多个lock进行锁定

方法2：具有相同的加锁顺序。意思是如果多个线程对多个Lock进行锁定，应该保证它们按照相同的顺序请求加锁

方法3：死锁检测。依靠一些算法机制来实现死锁的预防机制

方法4：使用定时锁。意思通过加锁设定time实现对锁的自动释放

6 栈实现队列

> 这个题目不知道遇到多少次，也不知道你们有多少人能够手撕出来。双栈思路即可

7  为什么需要timewait

> 1. 可靠的终止TCP连接。
> 2. 保证让迟来的TCP报文有足够的时间被识别并丢弃。前面有一篇文章专门介绍了这个问题哈

8 三次握手四次挥手 为什么四次

9 看程序写结果，构造函数

10 了解ELF？大概说说

> 使用readelf可查看较详细内容，画个图


<div align="center"> <img src="https://github.com/MikeCreken/Interview-site-Lan/blob/master/%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%E8%AF%A6%E8%A7%A3/%E6%8B%9B%E9%93%B6/img/test3.png?raw=true" width="650px" /> </div><br>

11 自旋锁

> 是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

ok，看到这里，都是人才，小蓝给大家大哥大姐们唱首歌高兴高兴！。。。。不高兴来打我！

## 2 二面(50分钟)

> 二面技术面试是当天下午就开始面了，整个技术面试对项目刨根问底哒，所以小伙伴写在简历上的项目一定需要吃透哟，不管是本公司还是其他公司，二面三面基本上都离不开问项目哈

1 自我介绍

2 项目介绍

- 项目背景
- 你做了什么
- 什么难点
- 项目所有知识点都问了且给你扩展(很棒)

3 智能指针是什么

> 智能指针类将一个计数器与类指向的对象相关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置为1；当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。智能指针就是模拟指针动作的类。所有的智能指针都会重载 -> 和 * 操作符。智能指针还有许多其他功能，比较有用的是自动销毁。这主要是利用栈对象的有限作用域以及临时对象（有限作用域实现）析构函数释放内存。

其他回答角度：

- 智能指针的设计思想
- 为什么摒弃auto_ptr
- unique_ptr为什么优于auto_ptr
- 如何选择只能指针

4 IO密集型和cpu密集型

> CPU密集型通常需要执行大量的CPU运算任务，这个时候保持线程数和CPU核数相当即可，不然容易更多的线程上下文切换。再web系统开发中，更多的可能是对于数据库的查询等IO操作，此时CPU会空闲一段下来。

5 两个线程顺序打印26个字母(通知机制)

```java
package com.jiahuilin;
 
import java.util.concurrent.Semaphore;
 
public class SemaphoreTest {
    static Semaphore semaphore1=new Semaphore(1,true);
    static Semaphore semaphore2=new Semaphore(1,true);
    static Thread t1, t2;
    public static void main(String[] args) throws InterruptedException {
        t1 = new Thread(() -> {
            String az = "ABCDEFGHIJKLMNPQRSTUVWXYZ";
            try {
                for (int i = 0; i < az.length(); i++) {
                    semaphore1.acquire();
                   // System.out.println(Thread.currentThread().getName()+"进来了");
                    System.out.print(az.charAt(i));
                    //System.out.println(Thread.currentThread().getName()+"出去了");
                    semaphore2.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "t1");
 
        t2 = new Thread(() -> {
            int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25};
            try {
                semaphore2.acquire();
                for (int i = 0; i < arr.length; i++) {
                    semaphore2.acquire();
                    //System.out.println(Thread.currentThread().getName()+"进来了");
                    System.out.print(arr[i]);
                    //System.out.println(Thread.currentThread().getName()+"出去了");
                    semaphore1.release();
 
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
 
 
        }, "t2");
        t1.start();
        t2.start();
 
    }
}
```

6 c++中map底层实现，红黑树说一下

> 红黑树形式的存储的键值是有序的，同时红黑树的插入，删除可以在O(logn)的完成。

红黑树的性质

- 红黑树的每个节点要么是红色要么是黑色
- 红黑树的根节点一定是黑色
- 红黑树的所有外部节点都是黑色
- 红黑树的所有有红色节点的两个子节点一定是黑色节点
- 红黑树从根到任意一个外部节点的路径上的黑色节点的数目相同

说到map，也说说hashmap和Treemap。

> C++中unordered_map的底层是用哈希表来实现的，通过key的哈希路由到每一个桶（即数组）用来存放内容。通过key来获取value的时间复杂度就是O（1）。因为key的哈希容易碰撞，所以需要对碰撞做处理。unordered_map里的每一个数组（桶）里面存的其实是一个链表，key的哈希冲突以后会加到链表的尾部，这是再通过key获取value的时间复杂度就变成O(n），当碰撞很多的时候查询就会变慢。为了优化这个时间复杂度，map的底层就把这个链表转换成了红黑树，这样虽然插入增加了复杂度，但提高了频繁哈希碰撞时的查询效率，使查询效率变成O(log n)。

7 根据简历，hadoop spark flink区别

> 大数据框架。难免就会涉及到分布式集群相关的知识点。所以如果是后台开发的同学，建议至少的看几篇博客去了解下分布式相关原理和一些大数据框架原理。书籍<hadoop权威指南>最新版即可，如果是博客，可以参看厦门大学大数据实验室出的教材，理论结合实战且有代码结合

8 根据简历，为什么使用oracle数据库，为什么不用hbase或者mysql这些

> 简单的说就是在海量数据的处理能力上更有优势，并且在完整的存储解决方案。至于为什么不用hbase，这完全是对知识广度的考察，正好之前也用过。hbase优点

- Hbase单表可百亿行
- 面向列存储，支持独立检索且可以动态增加列
- WAL机制保证数据写入的时候不会因为集群异常而导致写入数据丢失Replication机制。

10 根据简历，你的流量获取是实时的还是离线处理的

11 根据简历，kafka几个topic，有没有出现消费者消费不过来

12 根据简历。为什么使用hdfs

> HDFS是一种分布式文件系统层，可对集群节点间的存储和复制进行协调。HDFS确保了无法避免的节点故障发生后数据依然可用，可将其用作数据来源，可用于存储中间态的处理结果，并可存储计算的最终结果。

13 线程池用过没，需要注意哪些事项

> 这里主要是考察大家对于各种连接池的理解。提前创建一定数量的连接，需要的时候直接使用即可，不用每次频繁的创建连接。常用的连接池有redis连接池，HTTP连接池等。这里会涉及到最大的连接数和最小的连接数。那么连接数的大小一般怎么控制？

- 当前连接数小于最小连接数，那么就创建连接
- 如果连接池有空闲则复用
- 如果此时当前连接数大于最大连接数，考虑设置超市等待，异常处理

14 说一下什么是缓冲区溢出

> 缓冲区溢出是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。
>
> 　　危害：在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。
>
> 　　造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。

15  线程绑核了解不

16 sql语句

17 你还有什么问题？

18 后续有同事联系你

## 3 三面hr面

1 自我介绍

2 独生子？他们在哪里工作，是做什么的

3  对公司的期许

4 未来的规划

5 本科成绩如何，硕士成绩如何 担任过班干部？拿过奖学金？

6 拿了几个offer了，为什么不去，为什么选择面试我们

7 对于公司比较在意哪几个方面

8 有女朋友吗，在哪里工作

9 能简单介绍项目吗

10 课余在哪里学习技术

11怎么看待薪水和加班

12 有什么需要问我的吗

- 公司有入职培训吗，培训地点是统一的还是各个分中心(反问我，你希望的是怎么样的)

> 以上问题的顺序可能不对，二面面试官帅气，三面面试官漂亮。接下来的小伙伴加油！

## 4 知识复盘

- 网络编程------Linux高性能服务器编程(游双)
- 操作系统------Linux内核设计与实现
- 后台开发------后台开发 核心技术与实践
- 算法------剑指offer+leetcode100

唠嗑

**我是小蓝，一个专为大家分享面试经验的蓝人。如果觉得文章不错或者对你有点帮助，感谢分享给你的朋友，也可在给小蓝给个star，这对小蓝非常重要，谢谢你们，下期再会。**


<div align="center"> <img src="https://github.com/MikeCreken/Interview-site-Lan/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%B7%A5%E5%85%B7/img/%E4%B8%AA%E4%BA%BA%E5%BE%AE%E4%BF%A1.png?raw=true" width="200px" /> </div><br>